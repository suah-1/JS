[
    {
        "id": 1,
        "question": "미들웨어(Middleware)에 대한 설명으로 틀린 것은?",
        "options": [
            "여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다.",
            "미들웨어의 서비스 이용을 위해 사용자와 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.",
            "소프트웨어 컴포넌트를 연결하기 위한 준비된 인터프리터 구조를 제공한다.",
            "여러 컴포넌트를 1대1, 1대다, 다대다 등 여러 가지 형태로 연결이 가능하다."
        ],
        "correct": 2,
        "solution": "미들웨어는 운영체제와 응용 프로그램 간의 중간 역할을 하며, 내부 동작을 사용자에게 노출할 필요가 없습니다."
    },
    {
        "id": 2,
        "question": "UI의 설계 지침으로 틀린 것은?",
        "options": [
            "이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다.",
            "주요 기능을 메인 화면에 노출하여 조작이 쉬워야 한다.",
            "치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.",
            "사용자의 직무, 연령, 성별 등 다양한 계층을 수용해야 한다."
        ],
        "correct": 3,
        "solution": "치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다는 잘못된 설명입니다. 치명적인 오류는 반드시 사용자에게 인지되도록 해야 합니다."
    },
    {
        "id": 3,
        "question": "익스트림 프로그래밍에 대한 설명으로 틀린 것은?",
        "options": [
            "대표적인 구조적 방법론 중 하나이다.",
            "소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.",
            "익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.",
            "구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다."
        ],
        "correct": 1,
        "solution":"익스트림 프로그래밍은 대표적인 구조적 방법론이 아니다. 익스트림 프로그래밍은 애자일 방법론 중 하나로, 개발자가 독립적으로 작업하는 것이 아니라 협업 중심으로 이루어집니다."
    },
    {
        "id": 4,
        "question": "유스케이스(Use Case)의 구성 요소 간의 관계에 포함되지 않는 것은?",
        "options": [
            "연관",
            "확장장",
            "구체화",
            "일반화"
        ],
        "correct": 3,
        "solution":"구체화는 유스케이스의 관계에서 포함되지 않는 항목입니다. 유스케이스 간의 관계에는 연관, 확장장, 일반화가 포함됩니다."
    },
    {
        "id": 5,
        "question": "요구사항 분석에서 비기능적(Nonfunctional) 요구에 대한 설명으로 옳은 것은?",
        "options": [
            "시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다.",
            "'차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다.",
            "시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다.",
            "'금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다'는 비기능적 요구이다."
        ],
        "correct": 2,
        "solution":"'차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구가 맞습니다. 비기능적 요구는 성능, 보안, 신뢰성 등과 관련된 요구입니다."
    },
    {
        "id": 6,
        "question": "정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는?",
        "options": [
            "Package Diagram",
            "State Transition Diagram",
            "Deployment Diagram",
            "Entity-Relationship Diagram"
        ],
        "correct": 4,
        "solution":"정보공학 방법론에서 데이터베이스 설계는 **ERD(Entity Relationship Diagram)**로 표현됩니다."
    },
    {
        "id": 7,
        "question": "미들웨어(Middleware)에 대한 설명으로 틀린 것은?",
        "options": [
            "여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다.",
            "미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법등의 내부 동작을 쉽게 확인할 수 있어야 한다.",
            "소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다.",
            "여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러 가지 형태로 연결이 가능하다."
        ],
        "correct": 2,
        "solution":"미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법등의 내부 동작을 쉽게 확인할 수 있어야 한다는 설명은 틀립니다. 미들웨어는 시스템 간 연결을 제공하는 소프트웨어로, 내부 동작을 사용자가 알 필요는 없습니다."
    },
    {
        "id": 8,
        "question": "UI의 설계 지침으로 틀린 것은?",
        "options": [
            "이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다.",
            "주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다.",
            "치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.",
            "사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 한다."
        ],
        "correct": 3,
        "solution":"UI 설계 지침에서 '사용자 불편을 초래하는 복잡한 인터페이스'는 잘못된 설명입니다."
    },
    {
        "id": 9,
        "question": "객체지향 개념에서 다형성(Polymorphism)과 관련한 설명으로 틀린 것은?",
        "options": [
            "다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.",
            "다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.",
            "메소드 오버라이딩(Overriding)은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다.",
            "메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다."
        ],
        "correct": 4,
        "solution":"다형성은 같은 메서드명이지만 다른 동작을 하는 것, 즉 매개변수나 객체에 따라 다르게 동작하는 것이죠."
    },
    {
        "id": 10,
        "question": "객체에 대한 설명으로 틀린 것은?",
        "options": [
            "객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다.",
            "객체는 공통 속성을 공유하는 클래스들의 집합이다.",
            "객체는 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재이다.",
            "객체의 상태는 속성값에 의해 정의된다."
        ],
        "correct": 2,
        "solution":"객체는 인스턴스화된 클래스의 실체로, 속성과 메서드로 구성됩니다."
    },
    {
        "id": 11,
        "question": "속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?",
        "options": [
            "Inheritance",
            "Class",
            "Encapsulation",
            "Association"
        ],
        "correct": 3,
        "solution":"캡슐화는 속성과 연산을 하나로 묶는 객체지향 개념입니다."
    },
    {
        "id": 12,
        "question": "애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?",
        "options": [
            "변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.",
            "프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다.",
            "협상과 계약보다는 고객과의 협력을 중시한다.",
            "문서 중심이 아닌, 실행 가능한 소프트웨어를 중시한다."
        ],
        "correct": 1,
        "solution":"애자일은 짧은 개발 주기와 자주 변화하는 요구사항을 반영하는 방법론으로, 모든 프로젝트에 일률적으로 적용될 수 없다는 점이 틀린 설명입니다."
    },
    {
        "id": 13,
        "question": "명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?",
        "options": [
            "Model",
            "Sheet",
            "Component",
            "Cell"
        ],
        "correct": 3,
        "solution":"모듈은 독립적이고 인터페이스를 통해 접근하며 재사용 가능한 시스템의 부분입니다."
    },
    {
        "id": 14,
        "question": "GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?",
        "options": [
            "Adapter 패턴",
            "Bridge 패턴",
            "Builder 패턴",
            "Proxy 패턴"
        ],
        "correct": 3,
        "solution":"비지터 패턴은 구조 패턴이 아닌 행동 패턴에 속합니다."
    },
    {
        "id": 15,
        "question": "UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?",
        "options": [
            "Feedback",
            "Posture",
            "Module",
            "Hash"
        ],
        "correct": 1,
        "solution":"피드백은 시스템 상태와 진행 상황을 사용자가 이해할 수 있도록 도와줍니다."
    },
    {
        "id": 16,
        "question": "통신을 위한 프로그램을 생성하여 포트를 할당하고, 클라이언트의 통신 요청 시 클라이언트와 연결하는 내·외부 송·수신 연계기술은?",
        "options": [
            "DB링크 기술",
            "소켓 기술",
            "스크럼 기술",
            "프로토타입 기술"
        ],
        "correct": 2,
        "solution":"소켓 프로그래밍은 포트 할당과 통신 요청 처리 기술입니다."
    },
    {
        "id": 17,
        "question": "객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?",
        "options": [
            "메시지(Message)",
            "캡슐화(Encapsulation)",
            "다형성(Polymorphism)",
            "상속(Inheritance)"
        ],
        "correct": 2,
        "solution":"캡슐화는 데이터와 함수를 묶어 외부와의 경계를 만드는 과정입니다."
    },
    {
        "id": 18,
        "question": "GoF(Gangs of Four) 디자인 패턴의 생성패턴에 속하지 않는 것은?",
        "options": [
            "추상 팩토리(Abstract Factory)",
            "빌더(Builder)",
            "어댑터(Adapter)   ",
            "싱글턴(Singleton)"
        ],
        "correct": 3,
        "solution":"싱글턴 패턴은 생성 패턴이지만 GoF의 생성 패턴에 속하지 않는 것은 없습니다."
    },
    {
        "id": 19,
        "question": "바람직한 소프트웨어 설계 지침이 아닌 것은?",
        "options": [
            "모듈의 기능을 예측할 수 있도록 정의한다.",
            "이식성을 고려한다.",
            "적당한 모듈의 크기를 유지한다.",
            "가능한 모듈을 독립적으로 생성하고 결합도를 최대화한다."
        ],
        "correct": 4,
        "solution":"과도한 복잡성은 바람직한 설계 지침이 아닙니다."
    },
    {
        "id": 20,
        "question": "현행 시스템 분석에서 고려하지 않아도 되는 항목은?",
        "options": [
            "DBMS 분석",
            "네트워크 분석",
            "운영체제 분석",
            "인적 자원 분석"
        ],
        "correct": 4,
        "solution":"인적 자원 분석은 현행 시스템 분석에서 고려하지 않아도 됩니다."
    },
    {
        "id": 21,
        "question": "다음 중 요구사항 모델링에 활용되지 않는 것은?",
        "options": [
            "애자일(Agile) 방법",
            "유스케이스 다이어그램(Use Case Diagram)",
            "시퀀스 다이어그램(Sequence Diagram)",
            "단계 다이어그램(Phase Diagram)"
        ],
        "correct": 4,
        "solution":"단계 다이어그램은 요구사항 모델링에 활용되지 않습니다."
    },
    {
        "id": 22,
        "question": "디자인 패턴을 이용한 소프트웨어 재사용으로 얻어지는 장점이 아닌 것은?",
        "options": [
            "소프트웨어 코드의 품질을 향상시킬 수 있다.",
            "개발 프로세스를 무시할 수 있다.",
            "개발자들 사이의 의사소통을 원활하게 할 수 있다.",
            "소프트웨어의 품질과 생산성을 향상시킬 수 있다."
        ],
        "correct": 2,
        "solution":"개발 프로세스를 무시할 수 있다는 잘못된 설명입니다. 디자인 패턴은 개발 프로세스를 개선할 수 있지만, 무시할 수는 없습니다."
    },
    {
        "id": 23,
        "question": "스택에 대한 설명으로 틀린 것은?",
        "options": [
            "입출력이 한쪽 끝으로만 제한된 리스트이다.",
            "Head(front)와 Tail(rear)의 2개 포인터를 갖고 있다.",
            "LIFO 구조이다.",
            "더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다."
        ],
        "correct": 2,
        "solution":"Head(front)와 Tail(rear)의 2개 포인터를 갖고 있다는 설명은 틀립니다. 스택은 하나의 포인터만으로 동작하는 LIFO(후입선출) 구조입니다."
    },
    {
        "id": 24,
        "question": "디지털 저작권 관리(DRM)에 사용되는 기술요소가 아닌 것은?",
        "options": [
            "키관리",
            "방화벽",
            "암호화화",
            "크랙방지"
        ],
        "correct": 2,
        "solution":"암호화화는 잘못된 표현입니다. DRM에 사용되는 기술요소로는 암호화, 키관리, 방화벽, 크랙방지 등이 있지만 '암호화화'는 부적절한 설명입니다."
    },
    {
        "id": 25,
        "question": "다음 중 블랙박스 검사 기법은?",
        "options": [
            "경계값 분석",
            "조건 검사",
            "기초 경로 검사",
            "루프 검사"
        ],
        "correct": 1,
        "solution":"조건 검사는 블랙박스 검사 기법에 해당합니다. 다른 기법들은 내부 구조를 고려한 화이트박스 검사 기법입니다."
    },
    {
        "id": 26,
        "question": "이진 검색 알고리즘에 대한 설명으로 틀린 것은?",
        "options": [
            "탐색 효율이 좋고 탐색 시간이 적게 소요된다.",
            "검색할 데이터가 정렬되어 있어야 한다.",
            "피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다.",
            "비교횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다."
        ],
        "correct": 3,
        "solution": "피보나치 수열을 사용하지 않습니다 따라서 이는 피보나치 탐색이라는 별도의 알고리즘이 있습니다다."
    },
    {
        "id": 27,
        "question": "테스트 케이스에 일반적으로 포함되는 항목이 아닌 것은?",
        "options": [
            "테스트 조건",
            "테스트 데이터",
            "테스트 비용",
            "예상 결과"
        ],
        "correct": 3,
        "solution": "테스트 비용은 테스트 계획이나 프로젝트 관리에서 다루는 항목이지, 테스트 케이스의 필수 요소가 아닙니다다."
    },
    {
        "id": 28,
        "question": "소프트웨어 설치 매뉴얼에 포함될 항목이 아닌 것은?",
        "options": [
            "제품 소프트웨어 개요",
            "설치 관련 파일",
            "프로그램 삭제",
            "소프트웨어 개발 기간"
        ],
        "correct": 4,
        "solution": "소프트웨어 개발 기간은 설치와 관련이 없으므로 매뉴얼에 포함되지 않습니다다."
    },
    {
        "id": 29,
        "question": "뷰(VIEW)에 대한 설명으로 옳지 않은 것은?",
        "options": [
            "DBA는 보안 측면에서 뷰를 활용할 수 있다.",
            "뷰 위에 또 다른 뷰를 정의할 수 있다.",
            "뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다.",
            "독립적인 인덱스를 가질 수 없다."
        ],
        "correct": 3,
        "solution": "뷰는 삽입, 갱신, 삭제 시 제약이 많습니다다"
    },
    {
        "id": 30,
        "question": "E-R 다이어그램의 표기법으로 옳지 않은 것은?",
        "options": [
            "개체타입 - 사각형",
            "속성 - 타원",
            "관계집합 - 삼각형",
            "개체타입과 속성을 연결 – 선"
        ],
        "correct": 3,
        "solution": "관계(Relationship)은 삼각형이 아니라 마름모로 표현됩니다."
    },
    {
        "id": 31,
        "question": "알고리즘 설계 기법으로 거리가 먼 것은?",
        "options": [
            "Divide and Conquer    ",
            "Greedy",
            "Static Block.",
            "Backtracking"
        ],
        "correct": 3,
        "solution": "Static Block. → 알고리즘 설계 기법이 아닙니다. (프로그래밍 언어 개념)"
    },
    {
        "id": 32,
        "question": "제품 소프트웨어의 형상 관리 역할로 틀린 것은?",
        "options": [
            "형상 관리를 통해 이전 리버전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용    ",
            "불필요한 사용자의 소스 수정 제한",
            "프로젝트 개발비용을 효율적으로 관리",
            "동일한 프로젝트에 대해 여러 개발자 동시 개발 가능"
        ],
        "correct": 3,
        "solution": "형상 관리는 개발비용 관리와는 관련이 없습니다."
    },
    {
        "id": 33,
        "question": "제품 소프트웨어 패키징 도구 활용 시 고려사항이 아닌 것은?",
        "options": [
            "제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 고려한다.",
            "추가로 다양한 이기종 연동을 고려한다.",
            "사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.",
            "내부 콘텐츠에 대한 보안은 고려하지 않는다."
        ],
        "correct": 4,
        "solution":"내부 콘텐츠에 대한 보안은 반드시 고려해야 합니다."
    },
    {
        "id": 34,
        "question": "디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?",
        "options": [
            "콘텐츠 암호화 및 키 관리",
            "콘텐츠 식별체계 표현",
            "콘텐츠 오류 감지 및 복구",
            "라이센스 발급 및 관리"
        ],
        "correct": 3,
        "solution": "'디지털 저작권 관리(DRM) 기술'**은 디지털 콘텐츠의 불법 복제 및 배포를 방지하기 위한 기술로, 파일 암호화, 사용자 인증, 접근 제한 등을 포함합니다."
    },
    {
        "id": 35,
        "question": "물리데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?",
        "options": [
            "범위분할(Range Partitioning)",
            "해시분할(Hash Partitioning)",
            "조합분할(Composite Partitioning)",
            "유닛분할(Unit Partitioning)"
        ],
        "correct": 4,
        "solution": "일반적으로 파티션 유형은 기본 파티션, 확장 파티션, 논리 파티션 등으로 나눠집니다."
    },
    {
        "id": 36,
        "question": "저작권 관리 구성 요소에 대한 설명이 틀린 것은?",
        "options": [
            "콘텐츠 제공자(Contents Provider) : 콘텐츠를 제공하는 저작권자",
            "콘텐츠 분배자(Contents Distributor) : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능",
            "클리어링 하우스(Clearing House) : 키 관리 및 라이선스 발급 관리",
            "DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제"
        ],
        "correct": 2,
        "solution": "저작권 관리 구성 요소에는 저작권 보호, 콘텐츠 관리, 접근 제어 등이 포함됩니다."
    },
    {
        "id": 37,
        "question": " 블랙박스 테스트 기법으로 거리가 먼 것은?",
        "options": [
            "기초 경로 검사",
            "동치 클래스 분해",
            "경계값 분석",
            "원인 결과 그래프"
        ],
        "correct": 1,
        "solution": "단위 테스트나 흐름 분석과 같은 내부 로직을 확인하는 기법은 화이트박스 테스트에 해당하며, 이는 블랙박스 테스트와 거리가 먼 기법입니다."
    },
    {
        "id": 38,
        "question":"해싱함수 중 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식은?",
        "options": [
            "제산법",
            "폴딩법",
            "기수변환법",
            "숫자분석법"
        ],
        "correct": 2,
        "solution": "해시 함수 중 하나인 '나누기 해싱(Division Hashing)' 또는 **'XOR 해싱'**과 관련이 있습니다.이 방식은 레코드 키를 여러 부분으로 나누고, 각 부분을 더하거나 XOR 연산을 통해 결과값을 해시 주소로 사용하는 기법입니다."
    },
    {
        "id": 39,
        "question":"알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?",
        "options": [
            "단위 테스트",
            "인수 테스트",
            "통합 테스트",
            "시스템 테스트"
        ],
        "correct": 2,
        "solution": "알파 테스트(Alpha Testing)**와 **베타 테스트(Beta Testing)**는 소프트웨어의 최종 사용자 또는 개발팀 내 테스트에서 발견된 문제를 해결하기 위한 검증 단계입니다."
    },
    {
        "id": 40,
        "question":"디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?",
        "options": [
            "콘텐츠 암호화 및 키 관리",
            "콘텐츠 식별체계 표현",
            "콘텐츠 오류 감지 및 복구",
            "라이선스 발급 및 관리"
        ],
        "correct": 3,
        "solution": "디지털 저작권 관리(DRM) 기술은 디지털 콘텐츠의 불법 복제 및 배포를 방지하는 기술입니다."
    },
    {
        "id": 41,
        "question":"릴레이션 R의 모든 결정자(determinant)가 후보키이면 그 릴레이션 R은 어떤 정규형에 속하는가?",
        "options": [
            "제 1 정규형",
            "제 2 정규형",
            "보이스/코드 정규형",
            "제 4 정규형"
        ],
        "correct": 4,
        "solution": "릴레이션이 BCNF에 속하려면, 그 릴레이션의 모든 결정자(determinant)가 후보키여야 합니다. 여기서 결정자란, 속성 집합이 다른 속성들을 결정하는 경우를 말합니다. 후보키는 릴레이션에서 각 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합을 의미합니다. 따라서 모든 결정자가 후보키일 때, 해당 릴레이션은 BCNF에 속합니다."
    },
    {
        "id": 42,
        "question":"데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?",
        "options": [
            "CASE 분석",
            "일치 분석",
            "CRUD 분석   ",
            "연관성 분석"
        ],
        "correct": 3,
        "solution":"참조 동작 분석은 트랜잭션이 데이터베이스의 테이블과 어떻게 상호작용하는지 파악하기 위한 방법입니다."
    },
    {
        "id": 43,
        "question":"정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법은?",
        "options": [
            "인덱스정규화",
            "반정규화",
            "집단화   ",
            "머징"
        ],
        "correct": 2,
        "solution": "역정규화는 정규화된 데이터베이스 모델을 성능 향상 및 개발 운영의 단순화를 위해 일부러 중복, 통합, 분리 등을 수행하여 데이터베이스 성능을 높이는 기법입니다."
    },
    {
        "id": 44,
        "question":"학생 테이블을 생성한 후, 성별 필드가 누락되어 이를 추가하려고 한다. 이에 적합한 SQL 명령어는?",
        "options": [
            "INSERT",
            "ALTER",
            "DROP",
            "MODIFY"
        ],
        "correct": 2,
        "solution": "성별 필드를 학생 테이블에 추가하려면 ALTER TABLE 학생 ADD 성별 명령을 사용하여 새로운 성별 필드를 추가할 수 있습니다."
    },
    {
        "id": 45,
        "question":"정규화의 필요성으로 거리가 먼 것은?",
        "options": [
            "데이터 구조의 안정성 최대화",
            "중복 데이터의 활성화",
            "수정, 삭제 시 이상현상의 최소화",
            "테이블 불일치 위험의 최소화"
        ],
        "correct": 2,
        "solution": "정규화는 데이터베이스에서 중복을 최소화하고 무결성을 높이는 과정입니다. 이를 통해 데이터베이스의 유지보수 용이성 및 데이터 일관성 등을 개선할 수 있습니다."
    },
    {
        "id": 46,
        "question": "프로세스가 실행되면서 하나의 페이지를 일정시간 동안 집중적으로 액세스하는 현상은?",
        "options": [
            "구역성(locality)",
            "스래싱(thrashing)",
            "워킹세트(Working set)",
            "프리페이징(prepaging)"
        ],
        "correct": 1,
        "solution": "이 현상은 **지역성(Locality of Reference)**에 해당합니다."
    },
    {
        "id": 47,
        "question": "UNIX에서 파일 사용 권한 지정에 관한 명령어는?",
        "options": [
            "mv",
            "ls",
            "chmod",
            "fork"
        ],
        "correct": 3,
        "solution": "chmod 명령어는 UNIX 및 Linux 시스템에서 파일의 사용 권한을 변경하는 데 사용됩니다. 이 명령어를 통해 사용자는 파일에 대한 읽기(r), 쓰기(w), 실행(x) 권한을 설정할 수 있습니다."
    },
    {
        "id": 48,
        "question": "운영체제의 프로세스(Process)에 대한 설명으로 옳지 않은 것은?",
        "options": [
            "트랩 오류, 프로그램 요구, 입ㆍ출력 인터럽트에 대해 조치를 취한다.",
            "비동기적 행위를 일으키는 주체로 정의할 수 있다.",
            "실행중인 프로그램을 말한다.",
            "프로세스는 각종 자원을 요구한다."
        ],
        "correct": 1,
        "solution": "운영체제에서 프로세스는 실행 중인 프로그램의 인스턴스를 의미하며, 한 개 이상의 쓰레드를 가질 수 있습니다."
    },
    {
        "id": 49,
        "question": "공유자원을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 하며, 다른 프로세스가 공유자원에 대하여 접근하지 못하게 제어하는 기법은?",
        "options": [
            "mutual exclusion",
            "critical section",
            "deadlock",
            "scatter loading"
        ],
        "correct": 1,
        "solution": "상호배제는 공유 자원에 대한 접근을 한 번에 하나의 프로세스만 허용하는 기법입니다. 이 기법은 경쟁 조건(Race Condition)을 방지하기 위해 사용되며, 여러 프로세스가 동시에 자원에 접근하는 것을 막아 자원의 일관성을 보장합니다."
    },
    {
        "id": 50,
        "question": "운영체제의 역할로 가장 옳지 않은 것은?",
        "options": [
            "사용자 인터페이스 제공",
            "입ㆍ출력에 대한 보조역할 수행",
            "사용자들 간 하드웨어 자원의 공동 사용",
            "원시프로그램을 목적프로그램으로 변환"
        ],
        "correct": 4,
        "solution": "운영체제는 하드웨어 자원 관리뿐만 아니라 프로세스 관리, 메모리 관리, 파일 시스템 관리, 그리고 사용자와의 인터페이스 제공 등의 다양한 역할을 합니다."
    }

]
